Selection Sort    worst case: O(n^2); best case: O(n^2)
3 2 4 1
(find smallest -> swap to front)
1|  3   2   4
1   2|  3   4
1   2   3|   4
1   2   3   4|


Bubble Sort       worst case: O(n^2); best case: O(n)
3 2 4 1
(compare two elements -> swap)
2 - 3   4   1
2   3 - 4   1
2   3   1 -|4
2 - 3   1  |4
2   1 -|3  |4
1 -|2   3   4
|1  2   3   4


Insertion Sort     worst case: O(n^2); best case: O(n)
3   2   4   1
(sort elements one by one)
3|  2   4   1
2 - 3|  4   1
2   3 - 4|  1
2   3   1 - 4
2   1 - 3   4
1 - 2   3   4|



Recursion Sorting: 

Merge Sort         worst case: O(N*logN); best case: O(N*logN) 
4 3 5 6 2 1
(divide and conquer)
4 3 5    6 2 1
...
3 4 5    1 2 6       
3 4 5      2 6      -> 1
3 4 5        6      -> 1 2
  4 5        6      -> 1 2 3
    5        6      -> 1 2 3 4
             6      -> 1 2 3 4 5
                    -> 1 2 3 4 5 6


Recursion Sorting: 

Quick Sort       worst case: O(N^2); best case: O(N*logN) 
4 2 5 6 1 3

i is finding value great than pivot
j is finding value less or equal than pivot

Pivot = 4 

i is searching from 2
j is saerching from 3

i -> 5(5 is greater)
j -> 3(3 is less)
swap 3 and 5
4 2 3 6 1 5

i -> 6(6 is greater)
j -> 1(1 is less)
swap 6 and 1
4 2 3 1 | 6 5

2 3 1 4 6 5

1 2 3 4 6 5

1 2 3 4 5 6







