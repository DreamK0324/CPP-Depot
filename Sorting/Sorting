Selection Sort    worst case: O(n^2); best case: O(n^2)
3 2 4 1
(find smallest -> swap to front)
1|  3   2   4
1   2|  3   4
1   2   3|   4
1   2   3   4|


Bubble Sort       worst case: O(n^2); best case: O(n)
3 2 4 1
(compare two elements -> swap)
2 - 3   4   1
2   3 - 4   1
2   3   1 -|4
2 - 3   1  |4
2   1 -|3  |4
1 -|2   3   4
|1  2   3   4


Insertion Sort     worst case: O(n^2); best case: O(n)
3   2   4   1
(sort elements one by one)
3|  2   4   1
2 - 3|  4   1
2   3 - 4|  1
2   3   1 - 4
2   1 - 3   4
1 - 2   3   4|



Recursion: 
Merge Sort         worst case: O(N*logN); best case: O(N*logN) 
4 3 5 6 2 1
(divide and conquer)
4 3 5    6 2 1
...
3 4 5    1 2 6       
3 4 5      2 6      -> 1
3 4 5        6      -> 1 2
  4 5        6      -> 1 2 3
    5        6      -> 1 2 3 4
             6      -> 1 2 3 4 5
                    -> 1 2 3 4 5 6


Recursion: 
Quick Sort       worst case: O(N*logN); best case: O(N^2)
4 2 5 6 1 3

Pivot = 3 
4 > 3 -> I = 0, J = 0
4 2 5 6 1 3

2 < 3 -> I = 0, J = 1
2 4 5 6 1 3
 
5 > 3 -> I = 0, J = 1
2 4 5 6 1 3

6 > 3 -> I = 0, J = 1
2 4 5 6 1 3

1 < 3 -> I = 1, J = 2
2 1 5 6 4 3

J = 2
2 1 |3| 6 4 5













